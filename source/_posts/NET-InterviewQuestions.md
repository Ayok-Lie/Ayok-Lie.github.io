---
abbrlink: ''
categories:
- - 面试
date: '2025-08-04T11:02:24.646437+08:00'
tags:
- .Net面试题
title: 面试题库记载—1
updated: '2025-08-04T11:02:25.199+08:00'
---
#### 异步开发实现有哪些方式

异步方法 async task wait

Task.Run方法await Task.Run(()=>{});

Parallel并行编程，并行循环Parallel.For()，Parallel.Foreach()

通过事件（Event）异步调用

#### 项目开发中常用的设计模式

单例模式

抽象工厂

建造者模式

原型模式

适配器模式

桥接模式

责任链模式

#### MySql事务特性（ACID）

原子性(Atomicity)：事务是一个不可分割的工作单位，事务

中的所有操作要么全部成功，要么全部失败。如果其中一个操作失败，整个事务会被回滚到开始前的状态

一致性(Consistency)：事务必须保持数据库的一致性状态，即从一个有效状态转换到另一个有效状态。事务执行前后，数据库的完整性必须保持不变

隔离性(Isolation)：事务的隔离性确保一个事务的执行不受其它事务的影响。通过设置不同的隔离级别，可以控制事务间可见的数据修改程度。常见的隔离级别包含读未提交，读已提交，可重复度和串行化

持久性(Durability)：一旦事务提交，其对数据库的修改就是永久性的，即使系统发生故障也不会丢失。这意味着事务提交后数据会永久保存在数据库中

#### MySql中Innodb用的是什么存储结构，B+数和B数有什么区别

MySql中Innodb用的是B+数，区别1：B+数的数据是存在于叶子节点的，非叶子节点只存储键和指向子节点的指针，B树的数据是存放在所有的节点。区别2：B+树的叶子节点它是一个双向链表；B+树的这样一个设计能减少存储空间，让树的高度变低，减少IO的次数

#### 对多线程的了解？Thread和Task有啥区别

（1）基于不同的框架和API

Thread是基于Windows操作系统提供的API实现。
Task则是基于.NET框架提供的TPL（Task Parallel Library）实现。

（2）默认执行线程池：
Thread默认使用前台线程。
Task默认使用后台线程。

（3）异步执行：
Thread不支持异步执行。
Task支持异步执行。

（4）异常处理：
Thread需要在每个线程中处理异常。
Task提供了更好的异常处理机制。

（5）任务调度器：
Thread没有任务调度器。
Task提供了任务调度器，可以控制任务的并发性和调度方式。

（6）返回值：
Thread没有返回值。
Task可以有返回值。

#### 什么是缓存击穿、缓存穿透、缓存雪崩，如何解决？

（1）. 缓存击穿
定义：某个热点数据在缓存中过期时，大量请求同时涌入数据库，导致数据库压力骤增。

解决方案：

永不过期：对热点数据设置永不过期，通过后台更新缓存。

互斥锁：缓存失效时，使用互斥锁确保只有一个请求访问数据库并更新缓存，其他请求等待。

（2）. 缓存穿透
定义：大量请求查询不存在的数据，导致请求直接打到数据库，造成压力。

解决方案：

布隆过滤器：使用布隆过滤器快速判断数据是否存在，不存在则直接返回。

缓存空值：即使查询结果为空，也将空值缓存，并设置较短的过期时间。

（3）. 缓存雪崩
定义：大量缓存同时失效，导致所有请求直接访问数据库，数据库压力过大甚至崩溃。

解决方案：

分散过期时间：为缓存设置随机的过期时间，避免同时失效。

高可用架构：使用分布式缓存或集群，确保部分节点失效时系统仍能运行。

限流降级：在缓存失效时，通过限流和降级保护数据库。

#### GC垃圾回收机制

基本概念：GC负责跟踪应用程序中不再使用的对象，并舒服这些对象占用的内存。这种机制大大简化了内存管理任务，使得开发者能够更专注与编写业务逻辑代码，而无需过多关注内存分配和释放的细节

工作原理：C#的垃圾回收器使用了一种称为”标记-清除“（Mark-and-Sweep）的算法，其工作原理如下

标记阶段：垃圾回收器从根对象（通常是静态变量、线程栈上的局部变量、CPU寄存器中的引用等）开始，递归地访问这些对象引用的所有其他对象。被访问到的对象会被标记为“可达”或“存活”对象，表示这些对象仍然在使用中。
清除阶段：垃圾回收器会遍历堆内存，找到所有未被标记为可达的对象（即垃圾对象），并释放这些垃圾对象占用的内存空间，以供将来分配新的对象使用。
此外，在某些实现中，垃圾回收器还可能包括一个“压缩”阶段，即移动存活的对象，使它们重新从堆基地址开始连续排列，类似于磁盘空间的碎片整理。这样可以避免内存碎片问题，但移动对象会有一定的性能开销。

（3）、分代回收
C#的垃圾回收器是一种分代式垃圾回收器，它将对象按照其存活时间分为0代、1代和2代三个代数，每个代数有自己的内存区域。一般来说，0代对象的生命周期最短，2代对象的生命周期最长。垃圾回收器在进行垃圾回收时，会优先回收0代对象，然后是1代对象，最后是2代对象。这样可以提高垃圾回收的效率和性能。

（4）、并发回收
C#的垃圾回收器是一种并发式垃圾回收器，它可以在用户线程运行的同时进行部分垃圾回收工作，从而减少用户线程被暂停的时间。这有助于提高应用程序的响应速度和用户体验。
（5）、回收模式
C# GC有两种并发模式：工作站模式和服务器模式。工作站模式适用于单处理器或客户端应用程序，服务器模式适用于多处理器或服务器应用程序。此外，C# GC是一种可配置的垃圾回收器，它可以根据应用程序的需求和环境来调整垃圾回收的策略和参数。

#### JWT验证包含哪些部分

头部（Header）：包含了令牌的元数据，如令牌类型（type）和所使用的算法（alg）。

载荷（Payload）：包含了有关用户或其它数据的声明，如用户ID，用户名，权限等

签名（Signature）：用于验证JWT的真实性，确保JWT在传输过程中摸鱼被篡改。签名是通过将头部和载荷与一个密钥（Secret）结合，并使用头部中指定的签名算法生成

#### DDD聚合

领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性

#### 聚合根

如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实体，还是聚合的管理者。首先它作为实体本身，拥有实体的属性和业务行为，实现自身的业务逻辑。其次它作为聚合的管理者，在聚合内部负责协调实体和值对象按照固定的业务规则协同完成共同的业务逻辑。最后在聚合之间，它还是聚合对外的接口人，以聚合根ID关联的方式接受外部任务和请求，在上下文内实现聚合之间的业务协同。也就是说，聚合之间通过聚合根ID关联引用，如果需要访问其它聚合的实体，就要先访问聚合根，再导航到聚合内部实体，外部对象不能之间访问聚合内实体。

#### async和await关键字的作用是什么

async关键字用于标记方法，这个方法可以包含await操作。标记为async的方法返回一个Task或者Task<T>，甚至可以返回void，但是一般不建议（除非是事件处理器）

await关键字用于等待一个Task完成，而不会阻塞线程。它暂停方法的执行，直到异步任务完成，然后继续执行方法的剩余部分。这个关键字只能在标记为async的方法中使用

#### IQueryable接口与IEnumerable有什么区别

IQueryble是延迟执行的，这意味着查询是在访问数据时才实际执行。它主要用于构建动态查询，并且通常用于涉及远程数据源（如数据库）的场景，因为它能把查询转换为特定数据源所需的查询语言（如SQL）

IEnumerable是即使执行的，这意味着查询在调用时就立即执行，并且结果在内存中。这主要适用于处理内存中数据集合，通常用于集合已经在内存中的情况

#### 什么是ASP.NET Core？与ASP.NET MVC有什么区别

ASP.NET Core是一个开源的，跨平台的现代化框架，用于构建基于云的，互联网连接的应用程序。它是ASP.NET技术的进化版本，提供了更高的性能和灵活性。

ASP.NET MVC是一个在ASP.NET平台上用于创建传统Web应用程序的框架，基于Model-View-Controller（MVC）设计模式

ASP.NET Core与ASP.NET MVC的主要区别

跨平台性：ASP.NET Core可以在Windows，Linux和masOS平台运行，而ASP.NET MVC通常只能在Windows上运行。

性能：ASP.NET Core提供了更高的性能。微软对其进行了大量优化，使其比传统的ASP.NET更加轻量和快速

模块化：ASP.NET Core是高度模块化的，你可以自由选择需要的组件，这就减少了应用程序的体积和复杂性。ASP.NET MVC则包含了一套整的库，定制性不如ASP.NET Core

依赖注入：ASP.NET Core内置了依赖注入功能，增强了应用程序的测试性和可维护性。而在ASP.NET MVC中，通常需要手动配置第三方库来实现依赖注入

统一的开发模型：ASP.NET Core统一了MVC和Web API开发模型，简化了开发工作流程。

#### Entity Framework Core与Entity Framework6有什么区别

平台支持：EF Core是跨平台的，支持.NET Core和.NET Framework，而EF6仅支持.NET Framework。

性能和轻量化：EF Core进行了性能优化，更加轻量化，而EF6则比较重

新特性：EF Core引入了一些现代数据库交互特性，如全新的批量操作，混合客户端评估等

模型化方法：EF Core提供了更灵活的模型化方法，如无键实体（keyless entities）和拥有的实体类型（owned enetities）

#### 什么是ASP.NET Core中的过滤器？有哪些类型

ASP.NET Core中的过滤器（Filters）是一种用于在请求管道（Request Pipeline）中执行代码片段的机制。它们就像自定义的中间件，可以在处理请求的不同阶段执行特定的操作。使用过滤器，你可以把公共的逻辑从控制器动作中提取处理，从而减少代码冗余，提高代码的可维护性。

ASP.NET Core中常见的过滤器类型包括：

授权过滤器（Authorization Filters）：在执行控制器动作之前。负责检查用户是否具备访问权限

资源过滤器（Resource Filters）：在执行控制器动作之前和之后，执行与资源缓存等相关的逻辑

动作过滤器（Action Filters）：在执行控制器动作之前和之后，执行与动作方法相关的逻辑

异常过滤器（Exception Filters）：当控制器动作或过滤器出现未处理的异常时，执行相应的处理

结果过滤器（Result Filters）：在执行控制器动作结果之前和之后，执行与结果处理相关的逻辑

ASP.NET Core按以下顺序调用过滤器

Authorization Filters——>Resource Filters——>Action Filters——>Exception Filters——>Result Filters

#### .NET Core中的内存管理机制，如何避免内存泄漏

.NET Core的内存管理机制只要依赖垃圾回收（Garbage Collection，GC）系统。GC自动管理内存分配和释放，帮助开发者避免许多潜在的内存泄露问题。

垃圾回收（Garbage Collection，GC）：.NET Core使用一个搞笑的垃圾回收机制来自动管理内存。GC会定期检查内存，回收那些不再使用的对象，以便释放内存。

使用弱引用（WeakReference）：当需要缓存某些对象，但不希望阻止GC回收时，可以使用弱引用。这样即使这些对象仍然被引用，它们也不一定会被保留

正确使用IDisposable和using语法：对于需要手动释放资源的类型，如文件流，数据库连接等，实现IDisposable接口，并使用using语法确保只要的正确释放

事件和委托的解除：事件和委托的订阅未被及时接触也是常见的内存泄露源。确保在对象销毁前解除所有订阅事件和委托

#### TCP三次握手与四次挥手

##### 三次握手（建立连接）

目的：建立可靠连接，并同步双方的初始序列号

过程：

- 客户端—>服务端：发送SYN(seq=x)，请求建立连接
- 服务端—>客户端：回应SYN+ACK(seq=y,ack=x+1)，表示请求连接
- 客户端—>服务端：发送ACK(ack=y+1)，确认连接。

为什么要三次？

防止已失效的连接请求（旧SYN）被服务端误认为是新的连接。

##### 四次挥手（断开连接）

目的：双方都需要关闭自己的发送通道，确保数据完整性

过程：

- 客户端—>服务端：发送FIN，请求断开连接
- 服务端—>客户端：返回ACK，表示已收到
- 服务端—>客户端：服务端数据发送完毕，发送FIN
- 客户端—>服务端:返回ACK，连接关闭

为什么是四次？

因为TCP是全双工的，关闭连接需要双向各种关闭

https://discourse.gohugo.io/t/github-pages-deployment-died-with-fatal-no-url-found-for-submodule-path-themes-ananke-in-gitmodules/52940
